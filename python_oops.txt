from abc import ABC, abstractmethod

# --- 1. Abstract Base Class ---
# This is the blueprint for all employees.
class Employee(ABC):
    def __init__(self, name: str, employee_id: int, base_salary: float):
        self.name = name
        self.employee_id = employee_id
        self.base_salary = base_salary

    # A concrete method shared by all
    def get_profile(self) -> str:
        return f"Profile: {self.name} (ID: {self.employee_id})"

    # An abstract method. Subclasses MUST provide an implementation.
    @abstractmethod
    def calculate_monthly_pay(self) -> float:
        pass

# --- 2. Mixin Classes (Behaviors, similar to Traits) ---

# A mixin class for employees who can code
class CanWriteCode:
    def write_code(self, task: str) -> str:
        return f"Writing code for: {task}"

# A mixin class for employees who manage
class CanManagePeople:
    # We pass team_size in the main class __init__
    # This mixin assumes 'self' will have 'team_size'
    def conduct_meeting(self) -> str:
        # Assumes the implementing class has 'team_size'
        return f"Holding a meeting with {self.team_size} team members."

    def approve_vacation(self, name: str) -> str:
        return f"Approving vacation for {name}."

# --- 3. Concrete Classes (Inheritance) ---

# A Developer inherits from Employee and mixes in CanWriteCode
class Developer(Employee, CanWriteCode):
    def __init__(self, name: str, id: int, salary: float):
        # Initialize the base Employee class
        super().__init__(name, id, salary)
    
    # Must implement the abstract method
    def calculate_monthly_pay(self) -> float:
        bonus = 1000.0  # Developer bonus
        return (self.base_salary / 12) + bonus
    
    # We can also override mixin methods
    def write_code(self, task: str) -> str:
        return f"Developer {self.name} is expertly writing code for: {task}"

# A Manager inherits from Employee and mixes in CanManagePeople
class Manager(Employee, CanManagePeople):
    def __init__(self, name: str, id: int, salary: float, team_size: int):
        super().__init__(name, id, salary)
        self.team_size = team_size  # Specific to Manager
    
    # Must implement the abstract method
    def calculate_monthly_pay(self) -> float:
        bonus = self.team_size * 150.0  # Bonus based on team size
        return (self.base_salary / 12) + bonus

# A TechLead inherits from Employee and BOTH mixins
class TechLead(Employee, CanWriteCode, CanManagePeople):
    def __init__(self, name: str, id: int, salary: float, team_size: int):
        super().__init__(name, id, salary)
        self.team_size = team_size

    # Must implement the abstract method
    def calculate_monthly_pay(self) -> float:
        lead_bonus = 2500.0
        return (self.base_salary / 12) + lead_bonus

    # This class gets methods from ALL its parents
    def do_tech_lead_things(self):
        print(self.write_code("Architecting new system"))
        print(self.conduct_meeting())

# --- 4. Main script to Run the Demo ---
if __name__ == "__main__":
    dev = Developer("Alice Smith", 101, 120000)
    mgr = Manager("Bob Johnson", 201, 130000, 8)
    lead = TechLead("Charlie Brown", 301, 150000, 5)

    # --- Polymorphism ---
    # We can store all types in a list of the base class 'Employee'
    employees = [dev, mgr, lead]

    print("--- ðŸ’µ Employee Payroll ---")
    for emp in employees:
        print(emp.get_profile())
        # The correct calculate_monthly_pay() is called for each object type
        print(f"Monthly Pay: ${emp.calculate_monthly_pay():.2f}")
        print("---")

    # --- Calling Specific Mixin Methods ---
    print("\n--- ðŸš€ Specific Job Functions ---")
    
    # Developer functions
    print(dev.get_profile())
    print(dev.write_code("Fixing bug #123"))

    # Manager functions
    print(mgr.get_profile())
    print(mgr.conduct_meeting())
    print(mgr.approve_vacation("Alice"))

    # TechLead has methods from both mixins
    print(lead.get_profile())
    lead.do_tech_lead_things()