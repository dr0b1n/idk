import breeze.linalg._
import breeze.numerics._
import plotly._
import plotly.layout._
import plotly.Bar
import plotly.plot

// Placeholder Case Class for easy data handling
case class FruitSale(fruit: String, price: Double, quantity: Int)

object BreezePlotlyDemo {
  def main(args: Array[String]): Unit = {
    // --- 1. Load Data (Placeholder) ---

    // ðŸŽ IN A REAL PROJECT: You would use a library like Saddle or pure Scala 
    // to read a CSV and convert the columns to Breeze vectors/matrices, e.g.:
    // val data: Seq[FruitSale] = CsvReader.read("data.csv").map(row => FruitSale(row(0), row(1).toDouble, row(2).toInt))
    
    // Create minimal, in-memory placeholder data
    val salesData = Seq(
      FruitSale("Apple", 1.50, 100),
      FruitSale("Banana", 0.75, 200),
      FruitSale("Apple", 1.60, 50),
      FruitSale("Orange", 1.10, 80),
      FruitSale("Banana", 0.80, 150),
      FruitSale("Orange", 1.05, 40)
    )

    println("--- Raw Sales Data ---")
    salesData.foreach(s => println(s"Fruit: ${s.fruit}, Price: ${s.price}, Quantity: ${s.quantity}"))

    // --- 2. Numerical Computation with Breeze ---

    // a) Separate data into categories and numerical vectors
    val fruits: Seq[String] = salesData.map(_.fruit)
    
    // Create Breeze vectors from the numerical data
    val prices: DenseVector[Double] = DenseVector(salesData.map(_.price): _*)
    val quantities: DenseVector[Double] = DenseVector(salesData.map(_.quantity).map(_.toDouble): _*)

    // b) Calculate Transaction Revenue using element-wise multiplication (*)
    val transactionRevenues: DenseVector[Double] = prices * quantities
    
    // println("\n--- Transaction Revenues (Price * Quantity) ---")
    // println(transactionRevenues)
    
    // c) Aggregate Total Revenue by Fruit Type
    
    // Group the results using standard Scala collections operations
    val revenueMap: Map[String, Double] = fruits.zip(transactionRevenues.toArray)
      .groupBy(_._1) // Group by fruit name
      .mapValues(_.map(_._2).sum) // Sum the revenues for each fruit
      
    // d) Prepare final data for visualization
    val fruitNames: Seq[String] = revenueMap.keys.toSeq
    val totalRevenues: Seq[Double] = fruitNames.map(revenueMap)

    println("\n--- Total Revenue Per Fruit ---")
    fruitNames.zip(totalRevenues).foreach { case (fruit, rev) => 
      println(f"${fruit}: $$${rev}%.2f")
    }

    // --- 3. Visualization with Plotly.Scala ---

    // Create a Bar trace
    val barTrace = Bar(
      x = fruitNames, 
      y = totalRevenues,
      name = "Total Revenue"
    )

    // Define the Layout for the chart
    val layout = Layout(
      title = "Total Revenue per Fruit Type",
      xaxis = Axis(title = "Fruit Type"),
      yaxis = Axis(title = "Total Revenue (USD)")
    )

    // Create the Plot
    val plotData = Seq(barTrace)
    
    // Note: Plotly.Scala is designed to be used in environments that can render HTML 
    // (e.g., Jupyter, Zeppelin, or saved to a file).
    val plot = Plotly(plotData, layout)

    println("\n--- Plotly.Scala Output ---")
    println("Generating plot specification...")

    // To display the chart in a standalone application, you must save it to an HTML file.
    // This part requires a file system access and is illustrative:
    // plot.show() // requires a rendering backend
    // plot.write("fruit_revenue_barchart.html") 
    
    // Print a sample of the JSON specification for confirmation
    println(plot.as-->json.spaces2.take(300) + "...")
  }
}